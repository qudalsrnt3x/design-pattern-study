## Ch3. 데코레이터 패턴

### 필요한 이유

<strong>커피 클래스 관리 문제</strong>

```java
public class Beverage {
    String description;
    boolean milk;
    boolean soy;
    boolean mocha;
    boolean whip;
    
    //... 각각의 메서드
}
```
> 슈퍼클래스에 인스턴스 변수와 상속을 싸용해서 첨가물을 관리하게 되면 변경에 대한 문제가 발생한다.

- 첨가물 가격이 바꼈을 경우, 첨가물의 종류가 추가되었을 경우 기존 코드를 수정해야 한다.
- 해당 첨가물이 필요없는 음료의 경우 필요없는 부분까지 상속을 받아야 한다.

<br>

<strong>앞서 유연하고 재사용하기 쉬운 코드를 만들기 위해 몇가지 패턴을 배웠다.</strong> <br>

- 상속보다 구성(콤포지션)을 사용 <br>
- 구현보다 인터페이스에 맞춰서 프로그래밍한다.

### OCP

> 디자인 원칙 <br>
> 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.

- 데코레이터 패턴을 통해 OCP를 준수한 설계를 할 수 있다.

<br>


### 데코레이터 패턴

객체에 추가 요소를 동적으로 더할 수 있습니다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다.

- 기존 코드 수정 없이 행동을 확장할 수 있다.
- 상속 대신 데코레이터 패턴을 통해 행동을 확장할 수 있다.

<br>

<strong>커피 클래스에 데코레이터 패턴 적용</strong>
```java
// 1. DarkRoast 객체를 가져온다.
// 2. Mocha 객체로 장식한다.
// 3. Whip 객체로 장식한다.
// 4. cost() 메서드를 호출한다. 이때 첨가물의 가격을 계산하는 일은 해당 객체에게 위임한다.
```

### 데코레이터 패턴의 문제점

- 자잘한 클래스가 엄청나게 추가되는 경우가 발생한다.
- 추상 형식에 의존하는 것이 아니라 특정 형식에 의존하는 코드에 데코레이터를 사용하면 엉망이 되어버린다.
- 데코레이터로 꽤 많은 장식을 해야하는 경우가 있다.(코드가 복잡해진다.) -> 팩토리와 빌더 패턴으로 해결 가능